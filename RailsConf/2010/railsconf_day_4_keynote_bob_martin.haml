%h2 Twenty-five Zeros
%i Uncle Bob Martin
%p (Uncle Bob likes to talk about astrophysics :P)
%p The computing power of today is insanely faster and more robust, takes a ton less power, and is a LOT cheaper than the computers of 50 years ago.
%p The laptop sitting on your lap it probably 10^25th more powerful than a PDP-8 (a computer from the 1960s)
%ul
  %li What the hell have we done with all this amazing power in our hands?
  %li The if/loop statements in Fortran is essentially the same as it is in languages today.
  %li In Fortran 50 years ago we wrote: Assignment statements, if statements, and loops.
  %li In languages TODAY: We write assignment statements, if statements, and loops.
  %li Even though our hardware has become revolutionized (by 10^25th), BUT our software has not advanced all that much.
  %li "Structured Programming" - Go read this right now. This book is the reason why we do not write GOTO statements anymore. It is the book that taught us to use assignment statements, if statements, and loops.
  %li We dropped the GOTO statement after a while. In the same way, we now use TDD and Objects.
  %li Feb. 24, 1993 - Matz decided to make a better Perl. And Ruby was born.
  %li 1969 - C was invented
  %li 1971 - Smalltalk was invented by Alan Kay
  %li Smalltalk was based on Simula67, which was based on Algll60, which was based on Algol60 which was based on FORTRAN
  %li John McCarthy invented LISP in 1956. Which was based on IPL56, an assembly language based on list processing.
  %li C# was invented in 1999
  %li Java was invented because C++ was annoying.
  %li C++ was invented in 1979, it is C with classes. It made C look like Simula.
  %li C - 1969 by Ritchie. It was based on B, which was based on BCL, based on ... crap, I can't keep up..., but it goes back to Algol60
  %li Clojure (2008) based on Scheme, which was based on LISP with a little bit of Algol60.
%p The point, they ALL are based on the concepts of assignment statements, if statements, and loops. The cool thinking of today in programming is being recycled from the braintrust in the 1950s and 1960s.
%ul
  %li Ruby is just a slightly different twist from something thought up in the past.
  %li The paper "The Intergalactic Computer Network" described the Internet.
  %li In 1959 the first Internet was set up between 4 sites. The first message was "LOGIN"... but it crashed after the "LO" :P~
  %li The Internet gives us the Web. The horrible horrible web.
  %li "How many goddamn languages do you have to know to get a damn webpage up!"
  %li The basic messaging systems we use on the Web were pioneered in 1972. It is all basically the same stuff, just different.
%p The tech we create today is basically the same as before, but different.
%p We have been riding the wave of hardware innovation for years. Our software changes a lot in form, but very little in essence.
%ul
  %li Why the hell are we all using vi? Why aren't we harnessing the power of IDEs? Why can't we have that.
  %li Why are we testing business rules through the UI?
  %li You test the business rules without the UI all together, and the UI without the business rules.
%p Language waves
%ul
  %li The C Wave - Crested in the early 80s
  %li The C++ Wave - Cresting in the early 90s
  %li The Java Wave - Crested in the mid-2000s
  %li The Ruby Wave - Maybe haven't crested yet. But it will. It is the same.
%p Moore's Law is dead. Our hardware will no longer get twice as fast and twice as small every 18 months.
%ul
  %li The future will be different. We cannot ride the hardware roller coaster any longer.
  %li 30% of your microchips are used for caching.
  %li So now the hardware developers are taking out that cache, and giving us software peeps more processors.
  %li Oh crap. That means that we have to think about more than one machine.
  %li The whole reason functional languages are interesting to people now is that functional languages do multiprocessor programming well.
  %li Scala, F#: The big companies are making big complicated stuff.
  %li Clojure is awesome. Clojure is different. It is simple. It is awesome.
  %li "The Structure and Interpretation of Computer Programs." - READ THIS NOW!
  %li On page 216, they introduce an assignment statement. What!? We don't need assignment statements. It breaks everything.
  %li Multiple threads also makes things mega complicated.
%p "The Turing Omnibus" by Charles Petzold (Read this one too!)
%p The moral of the story: It is time for us to evolve. It is time for us to FINALLY start thinking differently about writing software.

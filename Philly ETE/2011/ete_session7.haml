// Mary Poppins meets the Matrix
%h3 #phillyete Session 7 Notes
%i Bruce Tate, bruce@rapidred.com
%p (This is a sales pitch for Bruce's book "Seven Languages in Seven Weeks")
%p How about seven languages in one hour. Bam!
%p What are the characters of each of these languages.
%p It is hard to quickly flip a reader's concepts. Bruce used movies.
%ul
  %li Ruby
  %li Io
  %li Prolog
  %li Scala
  %li Erlang
  %li Clojure
  %li Haskell
%p It is an important time to read about languages the you do not know. The paradigm of languages are changing right now!
%p The evolution of the microprocessor (multicore) has made this paradigm shift happen.
%p OO languages have not kept up, and functional languages have! Functional forever!
%h3 Prolog is like "Rainman"
%p You look at Prolog and say "how did he know that?"
%p And sometimes you say "how CAN'T he know that?"
%p Sometimes it is hard to figure out how Prolog does things.
%p There are somethings that should be simple that are hard to do, like set a variable.
%p Created around 1970 in the IO tradition of programs. It is an inspiration to a lot of programs.
%p Constraint-based logic programming. This is a hot field right now that Prolog kickstarted. Check it out.
%p Prolog is logic-based. You type the rules of the game and Prolog understands it.
%h3 Erlang is like "The Matrix"
%p Erlang does NOT have a pretty syntax.
%p Erlang was originally based on Prolog.
%p That is subjective. I suppose that in a world that only had BASIC or Prolog, or COBOL, Erlang is beautiful in comparison.
%p Object-oriented languages depend on mutability. Dr. Armstrong said that idea is POISON!
%p Erlang was built to solve concurrency problems on a very large scale.
%p Know when you crash, log it, and start another one. Dying is OK.
%p Erlang process starts are very very lightweight.
%p Erlang does message passing well while protecting you against the problems you will see in OO languages.
%h3 Haskell is like "Spock"
%p It is very logical, but has a hard time expressing itself.
%p Haskell was created by a committee and it is actually beautiful. WAU!
%p To print or log something in Haskell you have to understand the monad. And that is wicked hard, so... ;_;
%p Haskell is a lazy language that makes some things easy to do, like recursion.
%p In Haskell you can write something that would run forever if it was greedy, then you can only pick out what you want from a loop. Neat!
%p Static typing is not always a bad thing. Often in functional languages, good static typing can be a beautiful thing.
%p Haskell lets you use partially applied functions (a.k.a. currying) to simplify your function logic.
%h3 Ruby is like "Mary Poppins"
%p There is a lot of PASSION about Ruby in one way or another.
%p You either love it or you think it is dumb.
%p Ruby is a FUN language. But it is not "enterprisy" (but who likes that)
%p Ruby made metaprogramming accessible to Joe Programmer.
%p Ruby is like a gateway drug to awesome programming languages.
%p Ruby makes creating DSLs very easy.
%p Ruby makes creating state machines very easy.
%p Ruby isn't about optimization. It is optimized for the PROGRAMMER.
%p Ruby is going to remain a good language to express good ideas, but even Ruby will succumb to the power of functional paradigms.
%h3 Scala is like "Edward Scissorhands"
%p It is a monstrosity that is caught in-between two world (OO and Functional Programming)
%p Scala is a bridge language. From Java to a brave new world of functional goodness.
%p C++ was like C++-- (we really wrote C in C++)
%p Scala is like that for Java. We will use it to bridge to this new way of thinking.
%p If you come from a Java background it feels like some shackles are being thrown off, like currying, functional programming concepts, etc.
%p BUT if you come for a more dynaminc functional language Scala can feel really constrained.
%h3 Io is like "Ferris Buller"
%p Io is a prototype language. It was a hobby language built to learn how to build a language.
%p It is a superset of an OO language, like JavaScript.
%p It has a lot of strong opinions about syntax.
%p Io is the Lisp of the prototype world.
%p There is very little syntax with it.
%p But you can do a lot of naughty stuff with it.
%p It looks like Io is not going to make it, since JavaScript is a stronger competitor in this field of languages.
%p Io does concurrency very well.
%p It also makes metaprogramming very easy as well.
%p Io has a very small footprint as well. It is good as an embeddable scriptable environment.
%h3 Clojure is like "Yoda"
%p Lisp is in exile (like Yoda), and Clojure is a Lisp.
%p Clojure is a marriage of Java and Lisp, but more awesome.
%p Things that are sacred to Java devs are NOT sacred to Rich Hickey (the creator of Clojure)
%p Clojure allows you to do deconstruction and transform things quickly.
%p (See my Clojure notes for awesome detail)
%p Clojure and Java really really needs each other.
%ul
  %li Clojure needs a platform to support it.
  %li Java needs a reboot. A fresh start. Clojure is a new way for that.
%p Prolog: It will either expand your mind or blow it.
%p Prototype languages might be a better way to move into the future.
%p Haskell is cool to learn, because you have to deal with TRUE functional problems. You CANNOT have side effects. It is mind-expanding.
%p So check out Prolog, Haskell, and Io to start. They are cool.
%p The future is functional. Learn it. Love it.
%p Tank you Bruce for the great talk!
